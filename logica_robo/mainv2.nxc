#define DISTANCIA_ENTRE_RODAS 10 // cm
#define RAIO_RODA 10 // cm
#define MOTOR_E OUT_A // Motor da esquerda
#define MOTOR_D OUT_B // Mootor da direita
#define MOTOR_ED OUT_AB
//
#define COR_PRETA_LMI 44
#define COR_PRETA_LMS 49
#define COR_PRATA_LMI 54
#define COR_PRATA_LMS 59
//
#define LIGHT_IN IN_4
#define LIGHT_OUT S4
#define TOUCH_IN IN_3
#define TOUCH_OUT S3
//
#define PASSO_BUSCA 150 // Quantos graus ele avança antes de girar parea procurar uma saída

/**
 * turn_pct -> 100 para girar para direita e -100 para a esquerda
 */
void girar_eixo(short turn_pct){
	RotateMotorEx(MOTOR_ED, 20, 235, turn_pct, true, true);
    Off(MOTOR_ED);
}



/**
 * Quando control = false, a função é controlada com o módulo que conta passo
 * Quando control = true, a função fica igual  a segue_frente_ate_pare_linha()
 */
bool segue_frente(bool control){
	// Calcula qual deverá ser o grau que devo ir
    long passo_requerido = abs(MotorRotationCount(MOTOR_D)) + PASSO_BUSCA;
	// Se ainda não deu o angulo que preciso, nem toquei na parede e nem achei a linha preta, eu continuo em frente
    while(((abs(MotorRotationCount(MOTOR_D)) < passo_requerido) || control) && (!Sensor(TOUCH_OUT)) && (Sensor(LIGHT_OUT) < COR_PRETA_LMI || Sensor(LIGHT_OUT)> COR_PRETA_LMS)){
        OnFwdSync(MOTOR_ED, 20, 0);
    }
    Off(MOTOR_ED);
	// Após sair do while, preciso identificar o motivo. Verifico se foi por ter chegado no final de curso
	if ((Sensor(TOUCH_OUT)) && (Sensor(LIGHT_OUT) >= COR_PRETA_LMI && Sensor(LIGHT_OUT) <= COR_PRETA_LMS)){
		return true;
	}
	else{
		return false;
	}
}

/**
 * ACHO QUE N PRECISA VERIFICAR O FIM DE CURSO EM QUEM CHAMA ESSA FUNÇÃO. É DESNECESSÁRIO FAZER ISSO PQ A FUNÇÃO JÁ 
 * TERMINA NO FIM DE CURSO

bool segue_frente_ate_pare_linha(){
	// Se ainda não toquei na parede e nem achei a linha preta, eu continuo em frente
    while((!Sensor(TOUCH_OUT)) && (Sensor(LIGHT_OUT) < COR_PRETO_LMI || Sensor(LIGHT_OUT)> COR_PRETO_LMS)){
        OnFwdSync(MOTOR_ED, 20, 0);
    }
    Off(MOTOR_ED);
	// Após sair do while, preciso identificar o motivo. Verifico se foi por ter chegado no final de curso
	if ((Sensor(TOUCH_OUT)) && (Sensor(LIGHT_OUT) >= COR_PRETO_LMI && Sensor(LIGHT_OUT) <= COR_PRETO_LMS)){
		return true;
	}
	else{
		return false;
	}
}
 */

void sair_base(){
	// Enquanto não achar o prata
	bool fim_de_curso = false;
	girar_eixo(100);//90 para direita
	while ( Sensor(LIGHT_OUT) < COR_PRATA_LMI || Sensor(LIGHT_OUT)> COR_PRATA_LMS) {
		fim_de_curso = segue_frente(true);// era segue_frente_ate_pare_linha() segue em frente até achar uma parede ou linha (verifica se está em uma parede ou linha)
		if (fim_de_curso == true){
			// dá uma ré
			RotateMotorEx(MOTOR_ED, 20, (-1)*PASSO_BUSCA, 0, true, true);
			Off(MOTOR_ED);
			girar_eixo(-100);//90 graus para esquerda
		}

		fim_de_curso = segue_frente(false);//segue em frente por 100 graus (verifica se está em uma parede ou linha)
		if (fim_de_curso == true){
			// dá uma ré
			RotateMotorEx(MOTOR_ED, 20, (-1)*PASSO_BUSCA, 0, true, true);
			Off(MOTOR_ED);
			// Gira
			girar_eixo(-100);//90 graus para esquerda
		} else{
			girar_eixo(100);//90 para direita
		}
	}
	// Se achei o prata eu tomo minhas ações para sair daqui
	//DAR UM PRINT AQUI SÓ DE TESTE

}


task main(){
	SetSensorLight(LIGHT_IN);
	SetSensorTouch(TOUCH_IN);

}