// Right Motor        -> port A
// Left  Motor        -> port B
// Claw               -> port C
// Touch Sensor       -> port 3
// Ultrasonic Sensor  -> port 2
// Light Sensor       -> port 4

#include "BLUETOOTH.h"

#define LEFT_MOTOR  OUT_A
#define RIGHT_MOTOR OUT_B
#define CLAW        OUT_C
#define BOTH_MOTORS OUT_AB

#define ULTRASONIC_SENSOR  S2
#define TOUCH_SENSOR       S3
#define LIGHT_SENSOR       S2

#define TOUCH_SENSOR_STATE SENSOR_3
#define LIGHT_SENSOR_STATE SENSOR_2

#define TRACK 18
#define WHEEL_DIAMETER 5.6
#define DEFAULT_MOTOR_POWER 50
#define CLOCKWISE 0
#define COUNTERCLOCKWISE 1

void GoFoward(byte power, byte seconds);
void GoBackward(byte power, byte seconds);
// use defines
void TurnAround(byte direction, byte degrees);
void configSensors();
void grab();
void drop();
void getMailboxMessage(byte mailboxIdx);
byte robotDistance(byte port);

// use, by default mailbox 1
// read a mailbox and show it
// on NXT display
task readMailbox() {
     string in;
     in = bluetoothSlaveGet();
     TextOut(0, LCD_LINE1, in);
}

//task main() {
//  configSensors();
//  StartTask(readMailbox);
//  OnFwdSync(BOTH_MOTORS, 40, 0);
//  until(TOUCH_SENSOR_STATE == 1);
//  Off(BOTH_MOTORS);
//}

task main ()
{
    string in, out;
    while (true)
     {
        if (ReceiveMessage(1, true, in) == NO_ERR)
          {
            out = StrCat("Hello ", in);
            TextOut (0, LCD_LINE1, out, true);
            SendMessage (10, out);
          }
        else 
          {
            TextOut(0, LCD_LINE1, "OPA!");
            NumOut(0, LCD_LINE3, 10);
          }
      }
}

void GoFoward(byte power, byte seconds) {
     OnFwdSync(OUT_AB, power, 0);
     Wait(seconds*1000);
     Off(OUT_AB);
}

void GoBackward(byte power, byte seconds) {
     OnRevSync(OUT_AB, power, 0);
     Wait(seconds*1000);
     Off(OUT_AB);
}

// inputs
// -> direction must be
//      clockwise      counterclockwise
//          0                 1
//       CLOCKWISE     COUNTERCLOCKWISE
// -> degrees - how many degress it'll turn
void TurnAround(byte direction, byte degrees) {
     float trackCircunference, wheelCircunference;
     float distancePerDeg, distance2turn;
     long tachos2turn;
     trackCircunference = TRACK*PI;
     distancePerDeg = trackCircunference/360;
     distance2turn = distancePerDeg*degrees;
     wheelCircunference = WHEEL_DIAMETER*PI;
     tachos2turn = (distance2turn/wheelCircunference)*360;
     // left motor must go foward
     //OUT_A
     if (direction) {
        //RotateMotor(OUT_A, DEFAULT_MOTOR_POWER, tachos2turn);
        //RotateMotor(OUT_B, -DEFAULT_MOTOR_POWER, tachos2turn);
        RotateMotorEx(OUT_AB, DEFAULT_MOTOR_POWER, tachos2turn, 100, true, true);
     }
     // right motor must go foward
     // OUT_B
     else {
        //RotateMotor(OUT_B, DEFAULT_MOTOR_POWER, tachos2turn);
        //RotateMotor(OUT_A, -DEFAULT_MOTOR_POWER, tachos2turn);
     }
}

// set up the sensors connected
// to NXT, following init description
void configSensors() {
    SetSensorTouch(TOUCH_SENSOR);
    SetSensorUltrasonic(ULTRASONIC_SENSOR);
    SetSensorLight(LIGHT_SENSOR);
}

//fwd
// turn the motor connected in the CLAW
// over 90 deg
void grab() {
   RotateMotor(CLAW, 15, 90);
}

// rev
// turn the motor connected in the CLAW
// over -90 deg
void drop() {
   RotateMotor(CLAW, 15, -90);
}

void getMailboxMessage(byte mailboxIdx) {}

// read and return the robot
// distance to any object
byte robotDistance(byte port) {
     return SensorUS(port);
}
