#include "RPP.h"

#define MAX_BOX_MIN_DISTANCE 40
#define DISTANCIA_ENTRE_RODAS 10 // cm
#define DIAMETRO_RODA 5.6 // cm
#define MOTOR_E   OUT_A // Motor da esquerda
#define MOTOR_D   OUT_B // Mootor da direita
#define MOTOR_ED  OUT_AB
#define CLAW      OUT_C
//
#define DEFAULT_CLAW_POWER  50
#define CLOCKWISE           0
#define COUNTERCLOCKWISE    1
#define POWER               30
#define GRAU_PARA_GIRO_90   260
#define GRAU_PARA_GIRO_90_2  295
#define GRAU_PARA_GIRO_90_3  285
#define GRAU_PARA_GIRO_90_4 65
#define GRAU_PARA_GIRO_90_5 50

//
#define COR_PRETA_LMI 28
#define COR_PRETA_LMS 40
#define COR_PRATA_LMI 63
#define COR_PRATA_LMS 80
//
#define BLACK_COLOR  0
#define SILVER_COLOR 1
#define RED_COLOR    2
//
#define LIGHT_OUT S2
#define TOUCH_OUT S3
#define ULTRASONIC_OUT S4
#define ULTRASONIC_SENSOR  IN_4
#define TOUCH_SENSOR       IN_3
#define LIGHT_SENSOR       IN_2
//
#define PASSO_BUSCA 150 // Quantos graus ele avança antes de girar parea procurar uma saída
//
#define TOUCH_SENSOR_STATE SENSOR_3
#define LIGHT_SENSOR_STATE SENSOR_2

#define LEFT_SIDE  1
#define RIGHT_SIDE 2

/*
-----------------------
      Prototypes
-----------------------
*/
void handleSupervisorRequest(byte requestCodeb);
void treatSupervisorRequest();
void configureSensors();
void calcula_deslocamento();
void girar_eixo(short turn_pct);
void muda_bussola(short turn_pct);
//void playBeep(short frequency, byte ntimes);
void segue_frente(bool control);
void girar_eixo_v2(short turn_pct);
bool fim_de_curso();
void sair_base();
void achar_bancada();
void grab();
void drop();
bool isBoxPresent();
bool isNotTouched();
bool isTouched();
byte getRobotDistance();
byte getDetectedColor();
bool isBlackColorDetected();
bool isSilverColorDetected();
bool isRedColorDetected();
bool isNotBoxPresent();
unsigned int cm2deg(float cm);
void goBackward30cm();
void segue_frente_v2();
void turn180d();
void girar_eixo_v4(short turn_pct);
void girar_eixo_v5(short turn_pct);
void achar_base();
void turn180d2();
void pegar_caixa();
void sair_estoque();
void playBeep(byte ntime);
void achar_estoque();
void goFoward(byte angle);
void playAlertBeep(byte ntime);
void segue_frente_v3();
void segue_frente_v4();
void goFoward30cmBetter();
void girar_eixo_v6(short turn_pct);
void goBackward30cm2();

float seno(int grau){
	if (grau==0) return 0.0;
	else if(grau==90) return 1.0;
	else if(grau==180) return 0.0;
	else if(grau==270) return -1.0;
}

float cosseno(int grau){
	if (grau==0) return 1.0;
	else if(grau==90) return 0.0;
	else if(grau==180) return -1.0;
	else if(grau==270) return 0.0;
}
/*
-----------------------
    Global Variables
-----------------------
*/
//enum REGIAO { BASE, BANCADA, PATIO, ESTOQUE };// PATIO é a região onde tem várias bancadas
long gr_ant_RE;// = MotorRotationCount(MOTOR_A);// Roda esquerda
long gr_ant_RD;// Roda direita -> grau da roda direita
mutex mutexRoda;// mutex para alterar os estados do robô

int orientacao;// Indica a orientação do robo -> (90)NORTE - (180)OESTE - (270)SUL - (0)LESTE
float deslocamento[2];//Indica o deslocamento em torno de X e Y respectivamente
mutex mutexDeslocamento;// mutex para alterar os estados do robô
mutex whichSideMutex;

byte regiao; // 0-> BASE, 1->BANCADA, 2->MEIO, 3->ESTOQUE
byte status;
bool RobotInOperation = false;// Indica se o robô está disponivel na base
mutex RobotInOperationMutex;

byte whichSide = 0;
byte robotStatus = AWAITING;
byte requestCode = UCHAR_MAX;

string requestMsg, msgToSend = "";
string dataMsgToSend, responseToRequest = "";
mutex messageMutex;

bool strangleBox = false;
mutex strangleBoxMutex;



/*
        =============================================
                        MODULOS BLUETOOTH
        =============================================
*/
/// @brief
/// @param requestCodeb
void handleSupervisorRequest(byte requestCodeb)
{
     if (!RobotInOperation && requestCodeb == GO)
     {
          robotStatus = ONGOING;
          RobotInOperation = true;
          regiao = 0;
          //Acquire(messageMutex);
          formatMessage(robotStatus, msgToSend);
          sendMessage(msgToSend, RESPONSE);
          //Release(messageMutex);
          PlaySound(SOUND_CLICK);
          /*sair_base();
          RotateMotorEx(MOTOR_ED, POWER, -200, 0, true, true);
          achar_estoque();
          pegar_caixa();
          sair_estoque();
          RotateMotorEx(MOTOR_ED, POWER, -150, 0, true, true);
          achar_bancada();
          achar_base();
          */
          //sair_base();
          //achar_estoque();
          //segue_frente_v3();
          //pegar_caixa();
          //sair_estoque();
          //achar_bancada();
          //achar_base();
     }
     else if (requestCodeb != GO) playAlertBeep(5);
}


void treatSupervisorRequest()
{
     byte requestCode;
     string recvdMessage;
     if (readMessage(recvdMessage))
     {
          ClearScreen();
          //Acquire(messageMutex);
          requestCode = parseMessage(recvdMessage);
          requestMsg = recvdMessage;
          //Release(messageMutex);
          TextOut(0, LCD_LINE1, "Received");
          TextOut(0, LCD_LINE2, recvdMessage);
          NumOut(0, LCD_LINE3, requestCode);
          TextOut(0, LCD_LINE4, recvdMessage[0]);
          TextOut(0, LCD_LINE5, recvdMessage[2]);
          //if (recvdMessage[0] == '1') TextOut(0, LCD_LINE8, "É IGUAL A 1");
          //if (recvdMessage[2] == '0') TextOut(0, LCD_LINE7, "É IGUAL A 0");
          //Wait(1000);
          handleSupervisorRequest(requestCode);
     }
}


/*
        =============================================
                MODULOS LÓGICA DO PROBLEMA
        =============================================
*/
void configureSensors() {
    SetSensorTouch(TOUCH_SENSOR);
    SetSensorUltrasonic(ULTRASONIC_SENSOR);
    SetSensorLight(LIGHT_SENSOR);
}


void girar_eixo_v2(short turn_pct){
	Acquire(mutexDeslocamento);
	calcula_deslocamento();
	Release(mutexDeslocamento);
	long passo_esquerdo = MotorRotationCount(MOTOR_E) + (-turn_pct/100)*GRAU_PARA_GIRO_90;
	long passo_direito = MotorRotationCount(MOTOR_D) + (turn_pct/100)*GRAU_PARA_GIRO_90;
	// Girando ambos
	OnFwdSync(MOTOR_ED, POWER, turn_pct);
	while ((MotorRotationCount(MOTOR_D) != passo_direito) && (MotorRotationCount(MOTOR_E) != passo_esquerdo)){}
	Off(MOTOR_ED);
	// Se estiver girando para esquerda
	if(turn_pct == -100){
		// Girando oq falta
		OnFwd(MOTOR_D, (turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_D) > passo_direito){}
		Off(MOTOR_D);
		// Girando oq falta
		OnFwd(MOTOR_E, (-turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_E) < passo_esquerdo){}
		Off(MOTOR_E);
	}
	// Se estiver girando para direita
	else{
		// Girando oq falta
		OnFwd(MOTOR_D, (turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_D) < passo_direito){}
		Off(MOTOR_D);
		// Girando oq falta
		OnFwd(MOTOR_E, (-turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_E) > passo_esquerdo){}
		Off(MOTOR_E);
	}
	muda_bussola(turn_pct);
}

void girar_eixo_v6(short turn_pct){
	//calcula_deslocamento();// PRECISO CHAMAR PARA EVITAR UM CALCULO EM UMA DIREÇÃO ERRADO
	//
	long passo_esquerdo = MotorRotationCount(MOTOR_E) + (-turn_pct/100)*GRAU_PARA_GIRO_90_5;
	long passo_direito = MotorRotationCount(MOTOR_D) + (turn_pct/100)*GRAU_PARA_GIRO_90_5;
	// Girando ambos
	OnFwdSync(MOTOR_ED, POWER, turn_pct);
	while ((MotorRotationCount(MOTOR_D) != passo_direito) && (MotorRotationCount(MOTOR_E) != passo_esquerdo)){}
	Off(MOTOR_ED);
	// Se estiver girando para esquerda
	if(turn_pct == -100){
		// Girando oq falta
		OnFwd(MOTOR_D, (turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_D) > passo_direito){}
		Off(MOTOR_D);
		// Girando oq falta
		OnFwd(MOTOR_E, (-turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_E) < passo_esquerdo){}
		Off(MOTOR_E);
	}
	// Se estiver girando para direita
	else{
		// Girando oq falta
		OnFwd(MOTOR_D, (turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_D) < passo_direito){}
		Off(MOTOR_D);
		// Girando oq falta
		OnFwd(MOTOR_E, (-turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_E) > passo_esquerdo){}
		Off(MOTOR_E);
	}
}



void girar_eixo_v4(short turn_pct){
	Acquire(mutexDeslocamento);
	calcula_deslocamento();
	Release(mutexDeslocamento);
	//
	long passo_esquerdo = MotorRotationCount(MOTOR_E) + (-turn_pct/100)*GRAU_PARA_GIRO_90_3;
	long passo_direito = MotorRotationCount(MOTOR_D) + (turn_pct/100)*GRAU_PARA_GIRO_90_3;
	// Girando ambos
	OnFwdSync(MOTOR_ED, POWER, turn_pct);
	while ((MotorRotationCount(MOTOR_D) != passo_direito) && (MotorRotationCount(MOTOR_E) != passo_esquerdo)){}
	Off(MOTOR_ED);
	// Se estiver girando para esquerda
	if(turn_pct == -100){
		// Girando oq falta
		OnFwd(MOTOR_D, (turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_D) > passo_direito){}
		Off(MOTOR_D);
		// Girando oq falta
		OnFwd(MOTOR_E, (-turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_E) < passo_esquerdo){}
		Off(MOTOR_E);
	}
	// Se estiver girando para direita
	else{
		// Girando oq falta
		OnFwd(MOTOR_D, (turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_D) < passo_direito){}
		Off(MOTOR_D);
		// Girando oq falta
		OnFwd(MOTOR_E, (-turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_E) > passo_esquerdo){}
		Off(MOTOR_E);
	}
	
	muda_bussola(turn_pct);
}


void girar_eixo_v5(short turn_pct){
	//calcula_deslocamento();// PRECISO CHAMAR PARA EVITAR UM CALCULO EM UMA DIREÇÃO ERRADO
	//
	long passo_esquerdo = MotorRotationCount(MOTOR_E) + (-turn_pct/100)*GRAU_PARA_GIRO_90_4;
	long passo_direito = MotorRotationCount(MOTOR_D) + (turn_pct/100)*GRAU_PARA_GIRO_90_4;
	// Girando ambos
	OnFwdSync(MOTOR_ED, POWER, turn_pct);
	while ((MotorRotationCount(MOTOR_D) != passo_direito) && (MotorRotationCount(MOTOR_E) != passo_esquerdo)){}
	Off(MOTOR_ED);
	// Se estiver girando para esquerda
	if(turn_pct == -100){
		// Girando oq falta
		OnFwd(MOTOR_D, (turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_D) > passo_direito){}
		Off(MOTOR_D);
		// Girando oq falta
		OnFwd(MOTOR_E, (-turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_E) < passo_esquerdo){}
		Off(MOTOR_E);
	}
	// Se estiver girando para direita
	else{
		// Girando oq falta
		OnFwd(MOTOR_D, (turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_D) < passo_direito){}
		Off(MOTOR_D);
		// Girando oq falta
		OnFwd(MOTOR_E, (-turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_E) > passo_esquerdo){}
		Off(MOTOR_E);
	}
}



bool fim_de_curso(){
	// Se o sensor de toque foi acionado ou se estou lendo um valor que está no intervalo da cor preta
	if ( Sensor(TOUCH_SENSOR) || (Sensor(LIGHT_OUT) > COR_PRETA_LMI && Sensor(LIGHT_OUT) < COR_PRETA_LMS)){
		return true;
	}
	return false;
}

void segue_frente(bool control){
	long passo_r = abs(MotorRotationCount(MOTOR_D)) + PASSO_BUSCA;//passo requerido
	// Sigo em frente enquanto: não achar linha preta, não achar linha prata, não achar parede, não tiver dado o passo de busca
	OnRevSync(MOTOR_ED, POWER, 0);
	while( ( (abs(MotorRotationCount(MOTOR_D)) < passo_r) || (!control))  && (!Sensor(TOUCH_OUT)) && (Sensor(LIGHT_OUT) < COR_PRETA_LMI || Sensor(LIGHT_OUT)> COR_PRETA_LMS) && (Sensor(LIGHT_OUT) < COR_PRATA_LMI || Sensor(LIGHT_OUT)> COR_PRATA_LMS)){
	}
	Off(MOTOR_ED);
}

void sair_base(){
	girar_eixo_v2(100);// Giro para direita
	Off(MOTOR_ED);
	// Se estou vendo a porta, encerro a busca
	while (!isSilverColorDetected()){
		// Se estou no fim de curso
		if (fim_de_curso()){
			//--- dou ré e giro esquerda
			RotateMotorEx(MOTOR_ED, POWER, 200, 0, true, true);
			Off(MOTOR_ED);
			girar_eixo_v2(-100);
			Off(MOTOR_ED);
			// ando frente e giro direita
			segue_frente(true);// sigo em frente controlado pelo passo
			if (!fim_de_curso()){
				girar_eixo_v2(100);
				Off(MOTOR_ED);
			}
		}
		else{
			// sigo em frente indefinido
			segue_frente(false);
		}
	}
	goFoward(200);
}


void sair_estoque(){
	Acquire(RobotInOperationMutex);
	regiao = 1;
	Release(RobotInOperationMutex);
	girar_eixo_v2(-100);// Giro para direita
	Off(MOTOR_ED);
	// Se estou vendo a porta, encerro a busca
	while (!isSilverColorDetected()){
		// Se estou no fim de curso
		if (fim_de_curso()){
			//--- dou ré e giro esquerda
			RotateMotorEx(MOTOR_ED, POWER, 200, 0, true, true);
			Off(MOTOR_ED);
			girar_eixo_v2(100);
			Off(MOTOR_ED);
			// ando frente e giro direita
			segue_frente(true);// sigo em frente controlado pelo passo
			if (!fim_de_curso()){
				girar_eixo_v2(-100);
				Off(MOTOR_ED);
			}
		}
		else{
			// sigo em frente indefinido
			segue_frente(false);
		}
	}
	grab();
}


task strangleBoxe()
{
    while (1)
    {
    	Acquire(strangleBoxMutex);
    	if (strangleBox) grab();
    	else if (!strangleBox) break;
    	Release(strangleBoxMutex);
    }
}


/*
Send robot position X and Y coordinates
every one sec
*/
// falta adicionar uma variavel de controle
// para quebrar o laco (com break)
task sendRobotPosition(){
	playBeep(3);
	while (1)
     	{
     	  //ClearScreen();
          //NumOut(0, LCD_LINE1, deslocamento[0]);
          //NumOut(0, LCD_LINE2, deslocamento[1]);
          Wait(900);
          //PlayTone(300, 1000);
          Acquire(RobotInOperationMutex);
          if (RobotInOperation){
               // Chama o mutex para não ler enquanto alguém muda
               Acquire(mutexDeslocamento);
               formatDataMessage(deslocamento[0], deslocamento[1], regiao, dataMsgToSend);
               //formatDataMessage(0, 0, regiao, dataMsgToSend);
               Release(mutexDeslocamento);
               sendMessage(dataMsgToSend, POSITION);
               playBeep(2);
          }
          /*else if (!RobotInOperation)
          {
	       	  PlayTone(300, 1000);
	       	  Release(RobotInOperationMutex);
		  break;
          } */         
          Release(RobotInOperationMutex);
     }

}
/*
Calcula a distância Percorrida a cada X tempos
*/
task odometria(){
	/*
	short i;
	for (i = 392; i < 1319; i=i+102){
		PlayTone(i, 700);
		Wait(500);
	}
	*/
	while (1)
	{

		//TextOut(6, LCD_LINE1, "ODOMETRIA RODANDO");
		Acquire(RobotInOperationMutex);
		if (RobotInOperation){
			TextOut(0, LCD_LINE1, "ROBÔ EM OPERACAO");
			Acquire(mutexDeslocamento);
			calcula_deslocamento();
			Release(mutexDeslocamento);
			Wait(500);
		}
		/*
		else if(!RobotInOperation)
		{
			TextOut(0, LCD_LINE1, "SAINDO ODO");
			Wait(1000);
			break;
		}*/
		Release(RobotInOperationMutex);
	}
}


/*
Read Supervisor messages and
show them on NXT display
*/
task readFirstSupervisorMessage()
{
     while (1)
     {
          ClearScreen();
          TextOut(5, LCD_LINE1, "Wait for the");
          TextOut(5, LCD_LINE2, "first msg");
          Acquire(RobotInOperationMutex);
          treatSupervisorRequest();
          if (RobotInOperation)
          {
               	Release(RobotInOperationMutex);
               	PlayTone(300, 2000);
               	break;
          }
          //playBeep(6);
          Release(RobotInOperationMutex);
     }
}


void playBeep(byte ntime)
{
	while (--ntime)
	{
		PlayTone(300, 500);
		Wait(500);
	}
}

void grab(){
     //RotateMotor(CLAW, 25, 90);
     //Off(CLAW);
     OnFwd(CLAW, DEFAULT_CLAW_POWER);
     Wait(1500);
     Off(CLAW);
}

void drop(){
     RotateMotor(CLAW, 25, -90);
     Off(CLAW);
}

void muda_bussola(short turn_pct){
	Acquire(mutexDeslocamento);
	/////// Ao girar para direita
	if(turn_pct == 100){
          orientacao = orientacao - 90;
	}
	/////// Ao girar para esquerda
	else if (turn_pct==-100){
          orientacao = orientacao + 90;
	}
    if (orientacao == 360) orientacao = 0;
	if (orientacao == -90) orientacao = 270;
	Release(mutexDeslocamento);
}

void calcula_deslocamento(){
     // Pego o grau atual
     long RE_Atual = MotorRotationCount(MOTOR_E);
     long RD_Atual = MotorRotationCount(MOTOR_D);
     // Com esta conta eu tenho o deslocamento nulo ao girar no proprio eixo
     long desloc_grau = ((RE_Atual -gr_ant_RE) + (RD_Atual -gr_ant_RD))/2;
     float desloc_cm = (2*PI*(DIAMETRO_RODA/2)*abs(desloc_grau)/360);
     // Atualizo o grau anterior do robo
     gr_ant_RE = RE_Atual;
     gr_ant_RD = RD_Atual;
     // Atualizo a distancia do proprio robo
	 // em X
    //  float direcao_rad = orientacao*(PI/180.0);
        deslocamento[0] = deslocamento[0] + cosseno(orientacao)*desloc_cm;// seno e  cosseno recebem o valor em rads
	//deslocamento[0] = desloc_cm;
	 // em Y
        deslocamento[1] = deslocamento[1] + seno(orientacao)*desloc_cm;
	//deslocamento[1] = orientacao;
    //  NumOut(5, LCD_LINE1, gr_ant_RE);
    //  NumOut(5, LCD_LINE2, gr_ant_RD);
     //
}


void segue_frente_v3()
{
	OnRev(OUT_A, POWER+3);
	OnRev(OUT_B, POWER);
	//OnRevSync(OUT_AB, POWER+10, 0);
	while (!isBlackColorDetected() && !isSilverColorDetected());
	Off(MOTOR_ED);
}


void segue_frente_v4()
{
	OnRev(OUT_A, POWER+4);
	OnRev(OUT_B, POWER);
	//OnRevSync(OUT_AB, POWER+10, 0);
	while (!isBlackColorDetected() && !isSilverColorDetected());
	Off(MOTOR_ED);
}


void achar_estoque(){
	Acquire(RobotInOperationMutex);
	regiao = 1;
	Release(RobotInOperationMutex);
	short subindo = 1;// para indicar que ele começa a busca pela porta subindo o mapa (indo por norte)
	// Enquanto não tiver chegado no estoque
	//OnRevSync(MOTOR_ED, POWER+10, 0);
	//while(!isBlackColorDetected() && !isSilverColorDetected()){
	//}
	//Off(MOTOR_ED);
	//segue_frente(false);
	segue_frente_v3();
	// Agora procuro a entrada do estoque (Aqui eu vou estar em frente ao possível preto)
	// Giro esquerda
	while(!isSilverColorDetected()){
		// Se estou vendo a porta, encerro a busca
		//if (Sensor(LIGHT_OUT) > COR_PRATA_LMI && Sensor(LIGHT_OUT) < COR_PRATA_LMS){
		//	break;
		//}
		// Se estou vendo uma parede, dou um 180
		if (isTouched()){
		       girar_eixo_v2(100*subindo);
		       Off(MOTOR_ED);
		       subindo = subindo*(-1);// para inverter os sentidos dos giros ao achar uma parede
		}
		// se estou vendo a linha preta
		else if (isBlackColorDetected()){
			// dou ré
			RotateMotorEx(MOTOR_ED, POWER, 200, 0, true, true);
			Off(MOTOR_ED);
			// giro esquerda
			girar_eixo_v2(-100*subindo);
			Off(MOTOR_ED);
			// sigo em frente controlado pelo passo
			segue_frente(true);
			// Se não for o fim de curso, giro direita
			if (!fim_de_curso()){
				girar_eixo_v2(100*subindo);
				Off(MOTOR_ED);
			}
		}
		else{
			//playAlertBeep(3);
			//playBeep(3);
			// sigo em frente indefinido
			segue_frente(false);
		}
	}
	//goFoward(613);
}

void achar_base(){
	short subindo = 1;// para indicar que ele começa a busca pela porta subindo o mapa (indo por norte)
	// Enquanto não tiver chegado no estoque
	OnRevSync(MOTOR_ED, POWER+10, 0);
	while((Sensor(LIGHT_OUT) < COR_PRETA_LMI || Sensor(LIGHT_OUT)> COR_PRETA_LMS) && (Sensor(LIGHT_OUT) < COR_PRATA_LMI || Sensor(LIGHT_OUT)> COR_PRATA_LMS)){
	}
	Off(MOTOR_ED);
	// Agora procuro a entrada do estoque (Aqui eu vou estar em frente ao possível preto)
	// Giro esquerda
	while(Sensor(LIGHT_OUT) < COR_PRATA_LMI || Sensor(LIGHT_OUT)> COR_PRATA_LMS){
		// Se estou vendo a porta, encerro a busca
		if (Sensor(LIGHT_OUT) > COR_PRATA_LMI && Sensor(LIGHT_OUT) < COR_PRATA_LMS){
			break;
		}
		// Se estou vendo uma parede, dou um 180
		else if (Sensor(TOUCH_OUT)){
		       girar_eixo_v2(-100*subindo);
		       Off(MOTOR_ED);
		       subindo = subindo*(-1);// para inverter os sentidos dos giros ao achar uma parede
		}
		// se estou vendo a linha preta
		else if (Sensor(LIGHT_OUT) > COR_PRETA_LMI && Sensor(LIGHT_OUT) < COR_PRETA_LMS){
			// dou ré
			RotateMotorEx(MOTOR_ED, POWER, 200, 0, true, true);
			Off(MOTOR_ED);
			// giro esquerda
			girar_eixo_v2(100*subindo);
			Off(MOTOR_ED);
			// sigo em frente controlado pelo passo
			segue_frente(true);
			// Se não for o fim de curso, giro direita
			if (!fim_de_curso()){
				girar_eixo_v2(-100*subindo);
				Off(MOTOR_ED);
			}
		}
		else{
			PlayTone(2000, 500);
			// sigo em frente indefinido
			segue_frente(false);
		}
	}
    RotateMotorEx(MOTOR_ED, POWER, -600, 0, true, true);
	Acquire(RobotInOperationMutex);
	regiao = 0;
	Release(RobotInOperationMutex);
}

/////////////////////////////////////////////////////////////////
void girar_eixo_v3(short turn_pct){
	Acquire(mutexDeslocamento);
	calcula_deslocamento();
	Release(mutexDeslocamento);
	long passo_esquerdo = MotorRotationCount(MOTOR_E) + (-turn_pct/100)*GRAU_PARA_GIRO_90_2;
	long passo_direito = MotorRotationCount(MOTOR_D) + (turn_pct/100)*GRAU_PARA_GIRO_90_2;
	// Girando ambos
	OnFwdSync(MOTOR_ED, POWER, turn_pct);
	while ((MotorRotationCount(MOTOR_D) != passo_direito) && (MotorRotationCount(MOTOR_E) != passo_esquerdo)){}
	Off(MOTOR_ED);
	// Se estiver girando para esquerda
	if(turn_pct == -100){
		// Girando oq falta
		OnFwd(MOTOR_D, (turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_D) > passo_direito){}
		Off(MOTOR_D);
		// Girando oq falta
		OnFwd(MOTOR_E, (-turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_E) < passo_esquerdo){}
		Off(MOTOR_E);
	}
	// Se estiver girando para direita
	else{
		// Girando oq falta
		OnFwd(MOTOR_D, (turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_D) < passo_direito){}
		Off(MOTOR_D);
		// Girando oq falta
		OnFwd(MOTOR_E, (-turn_pct/100)*POWER);
		while (MotorRotationCount(MOTOR_E) > passo_esquerdo){}
		Off(MOTOR_E);
	}
	muda_bussola(turn_pct);
}

void goFoward30cmBetter()
{
     	//long passo_g = abs(MotorRotationCount(MOTOR_D)) + 613;
     	//RotateMotorEx(MOTOR_ED, POWER, 613, 0, true, true);
	OnRev(OUT_A, POWER+3);
	OnRev(OUT_B, POWER);
	//OnRevSync(OUT_AB, POWER+10, 0);
	Wait(3400);
	Off(MOTOR_ED);
}

void achar_bancada(){
	playAlertBeep(7);
	grab();
	if (whichSide == RIGHT_SIDE) girar_eixo_v6(100);
	else if (whichSide == LEFT_SIDE) girar_eixo_v6(-100);
	RotateMotorEx(MOTOR_ED, POWER, -1420, 0, true, true);
	//girar_eixo_v6(100);
	//playBeep(4);
	short subindo = 1;
	//segue_frente(true);
	//segue_frente(false);
	girar_eixo_v2(-100);
	Off(MOTOR_ED);
	while (true){
		if (isSilverColorDetected() && (orientacao == 90 || orientacao == 270)){
			Wait(200);
			segue_frente(true);
			Off(MOTOR_ED);
			turn180d();
			Off(MOTOR_ED);
			RotateMotorEx(MOTOR_ED, POWER, 200, 0, true, true);
			Off(MOTOR_ED);
			drop();
			segue_frente(true);
			grab();
			segue_frente(true);
			girar_eixo_v2(-100*subindo);
			Off(MOTOR_ED);
			break;
		}
		if (isTouched()){
			turn180d();			
			Off(MOTOR_ED);
			subindo = subindo*(-1); // para inverter os sentidos dos giros ao achar uma parede
		}
		else if(isBlackColorDetected()){
			RotateMotorEx(MOTOR_ED, POWER, 200, 0, true, true);
			Off(MOTOR_ED);
			girar_eixo_v2(100*subindo);
			Off(MOTOR_ED);
			segue_frente(true);
			if (!isBlackColorDetected()){
				girar_eixo_v2(-100*subindo);
				Off(MOTOR_ED);
			}
		}
		else{
			// sigo em frente indefinido
			segue_frente(false);
			
		}
	}

}

void goBackward30cm()
{
//     long passo_g = abs(MotorRotationCount(MOTOR_D)) + 613;
     RotateMotorEx(MOTOR_ED, POWER, 620, 0, true, true);
     Off(MOTOR_ED);
}

void goBackward30cm2()
{
     RotateMotorEx(MOTOR_ED, POWER, 655, 0, true, true);
     Off(MOTOR_ED);
}


void goFoward(byte angle)
{
	long passo_g = abs(MotorRotationCount(MOTOR_D)) + angle;
	OnRevSync(MOTOR_ED, POWER, 0);
	while (abs(MotorRotationCount(MOTOR_D)) < passo_g);
	Off(MOTOR_ED);
}

void turn180d()
{
     girar_eixo_v2(-100);
     Wait(1000);
     girar_eixo_v4(-100);// era v3
}

bool isBoxPresent()
{
     return (getRobotDistance() <= MAX_BOX_MIN_DISTANCE && isNotTouched() ? true : false);
}

bool isTouched()
{
     return (Sensor(TOUCH_OUT) == 1 ? true : false);
}

bool isNotTouched()
{
     return !isTouched();
}

byte getRobotDistance()
{
     return SensorUS(ULTRASONIC_OUT);
}

byte getDetectedColor()
{
     byte reflectedLight = Sensor(LIGHT_OUT);
     if (reflectedLight >= COR_PRETA_LMI && reflectedLight <= COR_PRETA_LMS) return BLACK_COLOR;
     else if (reflectedLight >= COR_PRATA_LMI && reflectedLight <= COR_PRATA_LMS) return SILVER_COLOR;
     return UCHAR_MAX;
}

bool isBlackColorDetected()
{
     return (getDetectedColor() == BLACK_COLOR ? true : false);
}

bool isSilverColorDetected()
{
     return (getDetectedColor() == SILVER_COLOR ? true : false);
}

bool isRedColorDetected() { return true; }

bool isNotBoxPresent()
{
     return !isBoxPresent();
}		
			

void pegar_caixa()
{
	Acquire(RobotInOperationMutex);
	regiao = 2;
	Release(RobotInOperationMutex);
	RotateMotorEx(MOTOR_ED, POWER, -613, 0, true, true);
     	Off(MOTOR_ED);
     	//goFoward30cm();
	girar_eixo_v2(-100);
	Wait(1000);
	if (isBoxPresent())
	{
		//Acquire(whichSideMutex);
		whichSide = RIGHT_SIDE;
		//Release(whichSideMutex);
		PlaySound(SOUND_FAST_UP);
		turn180d();
		drop();
		Off(MOTOR_ED);
		goBackward30cm2();
		grab();
		//RotateMotorEx(MOTOR_ED, POWER, -613, 0, true, true);
		return;
	}
	girar_eixo_v5(-100);
	Wait(1000);
	if (isBoxPresent())
	{
		//Acquire(whichSideMutex);
		whichSide = RIGHT_SIDE;
		//Release(whichSideMutex);
		PlaySound(SOUND_FAST_UP);
		turn180d();
		drop();
		Off(MOTOR_ED);
		goBackward30cm();
		grab();
		//RotateMotorEx(MOTOR_ED, POWER, -613, 0, true, true);
		return;
	}
	girar_eixo_v5(100);
	turn180d();
	Wait(1000);
	if (isBoxPresent())
	{
		//Acquire(whichSideMutex);
		whichSide = LEFT_SIDE;
		//Release(whichSideMutex);
		PlaySound(SOUND_FAST_UP);
		turn180d();
		drop();
		Off(MOTOR_ED);
		goBackward30cm();
		grab();
		RotateMotorEx(MOTOR_ED, POWER, -100, 0, true, true);
		return;
	}
	girar_eixo_v5(100);
	Wait(1000);
	if (isBoxPresent())
	{
		//Acquire(whichSideMutex);
		whichSide = LEFT_SIDE;
		//Release(whichSideMutex);
		PlaySound(SOUND_FAST_UP);
		turn180d();
		drop();
		Off(MOTOR_ED);
		goBackward30cm();
		grab();
		RotateMotorEx(MOTOR_ED, POWER, -100, 0, true, true);
	}
	playAlertBeep(5);
}

void turn180d2()
{
     girar_eixo_v2(-100);
     Wait(1000);
     girar_eixo_v3(-100);// era v3
}


void segue_frente_v2()
{
	long passo_r = abs(MotorRotationCount(MOTOR_D)) + PASSO_BUSCA;//passo requerido
	// Sigo em frente enquanto: não achar linha preta, não achar linha prata, não achar parede, não tiver dado o passo de busca
	OnRevSync(MOTOR_ED, POWER, 0);
	while(isNotBoxPresent());
	Off(MOTOR_ED);
}

void playAlertBeep(byte ntime)
{
	while (ntime--)
	{
		PlayTone(2000, 500);
		Wait(700);
	}
}


task main (){
     strangleBox = true;
     SetVolume(100);
     regiao = 0;
     //
     orientacao = 90; // Começa voltado pro norte do mapa
     //
     deslocamento[0] = 0;
     deslocamento[1] = 0;
     //
     //RobotInOperation = true;
     //
     gr_ant_RE = MotorRotationCount(MOTOR_E);
     gr_ant_RD = MotorRotationCount(MOTOR_D);
     configureSensors();
     //goFoward30cmBetter();
     StartTask(sendRobotPosition);
     StartTask(readFirstSupervisorMessage);
     StartTask(odometria);
     while (!RobotInOperation);
     sair_base();
     achar_estoque();
     pegar_caixa();
     sair_estoque();
     achar_bancada();
     achar_base();
	 //RotateMotorEx(MOTOR_ED, POWER, -360, 0, true, true);
          //RotateMotorEx(MOTOR_ED, POWER, -150, 0, true, true);
          //achar_bancada();
          //achar_base();
     //StartTask(sendRobotPosition);
     //StartTask(odometria);
     // restante do codigo do robo
     //OnFwdSync(MOTOR_ED, POWER+20, 0);
     //Off(MOTOR_ED);
     //segue_frente_v2();
     //sair_base();
     //achar_estoque();
     //achar_bancada();
     //achar_base();
     //pegar_caixa();
     ///sair_estoque();
     //turn180d();
     //Wait(500);
     //OnRevSync(MOTOR_ED, POWER+20,0);
     //while((Sensor(LIGHT_OUT) < COR_PRATA_LMI || Sensor(LIGHT_OUT)> COR_PRATA_LMS)){
     //}
     //Off(MOTOR_ED);
     
     //RotateMotorEx(MOTOR_ED, POWER, GRAU_PARA_GIRO_90, 100, true, true);//DIREITA
     //RotateMotorEx(MOTOR_ED, POWER, GRAU_PARA_GIRO_90, -100, true, true);//ESQUERDA
}



// ------- Mudar o sair da base ------- //
// ------- Fazer a nova bussola ------- //

// Fazer teste para sentido do giro
// Fazer teste pro bluetooth acionar tudo
// Fazer teste do deslocamento na interface
// Mudar o teste da bussola

// FAZER A TASK QUE VAI DEIXAR O ROBO ENTRANDO NA OPERAÇÃO






// - fazer teste para chegar no estoque

