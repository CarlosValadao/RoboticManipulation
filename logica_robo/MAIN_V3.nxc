#include "RPP.h"

#define DISTANCIA_ENTRE_RODAS 10 // cm
#define RAIO_RODA 10 // cm
#define MOTOR_E   OUT_A // Motor da esquerda
#define MOTOR_D   OUT_B // Mootor da direita
#define MOTOR_ED  OUT_AB
#define CLAW      OUT_C
//
#define DEFAULT_CLAW_POWER  15
#define CLOCKWISE           0
#define COUNTERCLOCKWISE    1
#define POWER               25
#define GRAU_PARA_GIRO_90   242
//
#define COR_PRETA_LMI 28
#define COR_PRETA_LMS 40
#define COR_PRATA_LMI 65
#define COR_PRATA_LMS 76
//
#define LIGHT_OUT S4
#define TOUCH_OUT S3
#define ULTRASONIC_OUT S2 
#define ULTRASONIC_SENSOR  IN_2
#define TOUCH_SENSOR       IN_3
#define LIGHT_SENSOR       IN_4
//
#define PASSO_BUSCA 250 // Quantos graus ele avança antes de girar parea procurar uma saída
//
#define TOUCH_SENSOR_STATE SENSOR_3
#define LIGHT_SENSOR_STATE SENSOR_2
/*
-----------------------
      Prototypes
-----------------------
*/
void handleSupervisorRequest(byte requestCodeb);
void treatSupervisorRequest();
void configureSensors();
void calcula_deslocamento();
void girar_eixo(short turn_pct);
void muda_bussola(short turn_pct);
void grab();
void drop();
/*
-----------------------
    Global Variables
-----------------------
*/
//enum REGIAO { BASE, BANCADA, PATIO, ESTOQUE };// PATIO é a região onde tem várias bancadas
long gr_ant_RE;// = MotorRotationCount(MOTOR_A);// Roda esquerda
long gr_ant_RD;// Roda direita -> grau da roda direita
short regiao; // 0-> BASE, 1->BANCADA, 2->PATIO, 3->ESTOQUE
bool orientacao[4];// Indica a orientação do robo -> NORTE - OESTE - SUL - LESTE
long deslocamento[2];//Indica o deslocamento em torno de X e Y respectivamente
mutex roboMutex;// mutex para alterar os estados do robô

bool RobotInOperation = false;// Indica se o robô está disponivel na base
mutex RobotInOperationMutex;

byte robotStatus = AWAITING;
byte requestCode = UCHAR_MAX;

string requestMsg, msgToSend = "";
string dataMsgToSend, responseToRequest = "";
mutex messageMutex;



/* 
        =============================================
                        MODULOS BLUETOOTH
        =============================================
*/
/// 
/// @brief 
/// @param requestCodeb
void handleSupervisorRequest(byte requestCodeb)
{
     if (!RobotInOperation && requestCodeb == GO)
     {
          robotStatus = ONGOING;
          RobotInOperation = true;
          //Acquire(messageMutex);
          formatMessage(robotStatus, msgToSend);
          sendMessage(msgToSend, RESPONSE);
          //Release(messageMutex);
          byte i;
          for (i=0; i<2; i++)
          {
               PlayTone(2000, 200);
               Wait(1000);
          }
     }
     else if (requestCodeb != GO)
     {
          for (byte i=0; i < 5; i++)
          {
              PlayTone(300, 200);
              Wait(1000);
          }
     }
}

void treatSupervisorRequest()
{
     byte requestCode;
     string recvdMessage;
     if (readMessage(recvdMessage))
     {
          //ClearScreen();
          //Acquire(messageMutex);
          requestCode = parseMessage(recvdMessage);
          requestMsg = recvdMessage;
          //Release(messageMutex);
          TextOut(0, LCD_LINE1, "Received");
          TextOut(0, LCD_LINE2, recvdMessage);
          NumOut(0, LCD_LINE3, requestCode);
          TextOut(0, LCD_LINE4, recvdMessage[0]);
          TextOut(0, LCD_LINE5, recvdMessage[2]);
          //if (recvdMessage[0] == '1') TextOut(0, LCD_LINE8, "É IGUAL A 1");
          //if (recvdMessage[2] == '0') TextOut(0, LCD_LINE7, "É IGUAL A 0");
          //Wait(1000);
          handleSupervisorRequest(requestCode);
     }
}


/* 
        =============================================
                MODULOS LÓGICA DO PROBLEMA
        =============================================
*/
// set up the sensors connected
// to NXT, following init description
void configureSensors() {
    SetSensorTouch(TOUCH_SENSOR);
    SetSensorUltrasonic(ULTRASONIC_SENSOR);
    SetSensorLight(LIGHT_SENSOR);
}


void girar_eixo_v2(short turn_pct){
	//calcula_deslocamento();// PRECISO CHAMAR PARA EVITAR UM CALCULO EM UMA DIREÇÃO ERRADO
	//
	long passo_esquerdo = abs(MotorRotationCount(MOTOR_E)) + GRAU_PARA_GIRO_90;
	long passo_direito = abs(MotorRotationCount(MOTOR_D)) + GRAU_PARA_GIRO_90;
	// Girando ambos
	OnFwdSync(MOTOR_ED, POWER, turn_pct);
	while ((abs(MotorRotationCount(MOTOR_D)) < passo_direito) && (abs(MotorRotationCount(MOTOR_E)) < passo_esquerdo)){}
	Off(MOTOR_ED);
	// Girando oq falta
	OnFwd(MOTOR_E, POWER);
	while (abs(MotorRotationCount(MOTOR_E)) < passo_esquerdo){}
	Off(MOTOR_E);
	// Girando oq falta
	OnFwd(MOTOR_D, POWER);
	while (abs(MotorRotationCount(MOTOR_D)) < passo_direito){}
	Off(MOTOR_D);
	muda_bussola(turn_pct);
}

/**
 * Quando control = false, a função é controlada com o módulo que conta passo
 * Quando control = true, a função fica igual  a segue_frente_ate_pare_linha()
 */
bool segue_frente(bool control){
	// Calcula qual deverá ser o grau que devo ir
    long passo_r = abs(MotorRotationCount(MOTOR_D)) + PASSO_BUSCA;//passo requerido
	// Se ainda não deu o angulo que preciso, nem toquei na parede e nem achei a linha preta, eu continuo em frente
    //OnFwdSync(MOTOR_ED, POWER, 0);
    OnRevSync(MOTOR_ED, POWER, 0);
    while(((abs(MotorRotationCount(MOTOR_D)) < passo_r) || control) && (!Sensor(TOUCH_OUT)) && (Sensor(LIGHT_OUT) < COR_PRETA_LMI || Sensor(LIGHT_OUT)> COR_PRETA_LMS)){
    //while(((abs(MotorRotationCount(MOTOR_D)) < passo_r) || control) && (!Sensor(TOUCH_OUT)) && (Sensor(LIGHT_OUT) < COR_PRETA_LMI || Sensor(LIGHT_OUT)> COR_PRETA_LMS) && (Sensor(LIGHT_OUT) < COR_PRATA_LMI || Sensor(LIGHT_OUT)> COR_PRATA_LMS)){
	//OnFwdSync(MOTOR_ED, POWER, 0);
	}
    Off(MOTOR_ED);
	// Após sair do while, preciso identificar o motivo. Verifico se foi por ter chegado no final de curso
	if ((Sensor(TOUCH_OUT)) || (Sensor(LIGHT_OUT) >= COR_PRETA_LMI && Sensor(LIGHT_OUT) <= COR_PRETA_LMS)){
		return true;
	}
	else{
		return false;
	}
}


void sair_base(){
	// Enquanto não achar o prata
	bool fim_de_curso = false;
	//girar_eixo(-100);//90 para direita
     girar_eixo(100);
	while ( Sensor(LIGHT_OUT) < COR_PRATA_LMI || Sensor(LIGHT_OUT)> COR_PRATA_LMS) {
		fim_de_curso = segue_frente(true);// era segue_frente_ate_pare_linha() segue em frente até achar uma parede ou linha (verifica se está em uma parede ou linha)
		if (fim_de_curso == true){
			// dá uma ré
			RotateMotorEx(MOTOR_ED, POWER, -PASSO_BUSCA, 0, true, true);
			//OnRevReg(MOTOR_ED, POWER, 2);
			//Wait(200);
			Off(MOTOR_ED);
			//girar_eixo(100);//90 graus para esquerda
			girar_eixo(-100);//90 graus para esquerda
		} //else{ // Se parei de seguir em frente e não era fim de curso, significa que achei um prata
			//break;
		//}

		fim_de_curso = segue_frente(false);//segue em frente por 100 graus (verifica se está em uma parede ou linha)
		if (fim_de_curso == true){
			// dá uma ré
			//RotateMotorEx(MOTOR_ED, POWER, -PASSO_BUSCA, 0, true, true);
			RotateMotorEx(MOTOR_ED, POWER, PASSO_BUSCA, 0, true, true);
			//OnRevReg(MOTOR_ED, POWER, 2);
			//Wait(200);
			Off(MOTOR_ED);
			// Gira
			// girar_eixo(100);//90 graus para esquerda
			girar_eixo(-100);//90 graus para esquerda
		} else{
			// girar_eixo(-100);//90 para direita
			girar_eixo(100);//90 para direita
		}
	}
	// Se achei o prata eu tomo minhas ações para sair daqui
	//DAR UM PRINT AQUI SÓ DE TESTE
}


/*
Send robot position X and Y coordinates
every one sec
*/
// falta adicionar uma variavel de controle
// para quebrar o laco (com break)
task sendRobotPosition(){
	while (1)
     {    ClearScreen();
          NumOut(0, LCD_LINE1, deslocamento[0]);
          NumOut(0, LCD_LINE2, deslocamento[1]);
          Wait(900);
          Acquire(RobotInOperationMutex);
          if (RobotInOperation){
               // Chama o mutex para não ler enquanto alguém muda
               Acquire(roboMutex);
               formatDataMessage(deslocamento[0], deslocamento[1], dataMsgToSend);
               deslocamento[0] = deslocamento[0] + 1;
               deslocamento[1] = deslocamento[1] + 2;
               Release(roboMutex);
               sendMessage(dataMsgToSend, POSITION);
          }
          Release(RobotInOperationMutex);
     }	
}

/*
Read Supervisor messages and
show them on NXT display
*/
task readFirstSupervisorMessage()
{
     while (1)
     {
          ClearScreen();
          TextOut(5, LCD_LINE1, "Wait for the");
          TextOut(5, LCD_LINE2, "first msg");
          Acquire(RobotInOperationMutex);
          treatSupervisorRequest();
          if (RobotInOperation)
          {
               Release(RobotInOperationMutex);
               break;
          }
          Release(RobotInOperationMutex);
     }
}
/*
Calcula a distância Percorrida a cada X tempos
*/
task odometria(){
	short i;
	for (i = 392; i < 1319; i=i+102){
		PlayTone(i, 700);
		Wait(500);
	}

	startOdometerCalc:
	while (RobotInOperation){
		//calcula_deslocamento();
		Wait(100);
	}
	while (!RobotInOperation);
	goto startOdometerCalc;
}

void grab(){
     RotateMotor(CLAW, 25, 90);
     Off(CLAW);
}

void drop(){
     RotateMotor(CLAW, 25, -90);
     Off(CLAW);
}

void muda_bussola(short turn_pct){
	Acquire(roboMutex);
	/////// Ao girar para esquerda
	if(turn_pct == 100){
		if (orientacao[0]==true){// Se estiver para o NORTE
			// vai pro oeste
			orientacao[0]=false;
			orientacao[1]=true;
		} else if (orientacao[1]==true){// Se estiver para o OESTE
			// vai pro sul
			orientacao[1]=false;
			orientacao[2]=true;
		} else if (orientacao[2]==true){// Se estiver para o SUL
			// vai pro leste
			orientacao[2]=false;
			orientacao[3]=true;
		}
		else if (orientacao[3]==true){// Se estiver para o LESTE
			// vai pro norte
			orientacao[3]=false;
			orientacao[0]=true;
		}
	} 
	/////// Ao girar para direita
	else if (turn_pct==-100){
		if (orientacao[0]==true){// Se estiver para o NORTE
			// vai pro leste
			orientacao[0]=false;
			orientacao[3]=true;
		} else if (orientacao[1]==true){// Se estiver para o OESTE
			// vai pro norte
			orientacao[1]=false;
			orientacao[0]=true;
		} else if (orientacao[2]==true){// Se estiver para o SUL
			// vai pro oeste
			orientacao[2]=false;
			orientacao[1]=true;
		}
		else if (orientacao[3]==true){// Se estiver para o LESTE
			// vai pro sul
			orientacao[3]=false;
			orientacao[2]=true;
		}
	}
	Release(roboMutex);
}

void calcula_deslocamento(){
   // Pego o grau atual
   long RE_Atual = MotorRotationCount(MOTOR_E);
   long RD_Atual = MotorRotationCount(MOTOR_D);
   // Com esta conta eu tenho o deslocamento nulo ao girar no proprio eixo
   Acquire(roboMutex);
   long desloc_grau = ((RE_Atual -gr_ant_RE) + (RD_Atual -gr_ant_RD))/2;
   long desloc_cm = 2*PI*desloc_grau; 
   // Atualizo o grau anterior do robo
  gr_ant_RE = RE_Atual;
  gr_ant_RD = RD_Atual;
   
   // Atualizo a distancia do proprio robo
   //bool aux = ;
   //TextOut(5, LCD_LINE1, NumToStr(aux));
    if (orientacao[0] == true){// Se estiver para o NORTE
       deslocamento[1] = deslocamento[1] + desloc_cm;
    } else if (orientacao[1]==true){// Se estiver para o OESTE
       deslocamento[0] = deslocamento[0] - desloc_cm;
    } else if (orientacao[2]==true){// Se estiver para o SUL
       deslocamento[1] = deslocamento[1] - desloc_cm;
    } else if (orientacao[3]==true){// Se estiver para o LESTE
       deslocamento[0] = deslocamento[0] + desloc_cm;
    }//*/
    
	Release(roboMutex);
}

void girar_eixo(short turn_pct){
	calcula_deslocamento();// PRECISO CHAMAR PARA EVITAR UM CALCULO EM UMA DIREÇÃO ERRADO
	RotateMotorEx(MOTOR_ED, POWER, GRAU_PARA_GIRO_90, turn_pct, true, true);
	muda_bussola(turn_pct);
	Off(MOTOR_ED);
}


task main (){
   regiao = 0;
   //
   orientacao[0] = true;// Começa voltado pro norte do mapa
   orientacao[0] = false;
   orientacao[0] = false;
   orientacao[0] = false;
   //
   deslocamento[0] = 0;
   deslocamento[1] = 0;
   //
   gr_ant_RE = MotorRotationCount(MOTOR_E);
   gr_ant_RD = MotorRotationCount(MOTOR_D);
    configureSensors();
    //RobotInOperation = true;
    //StartTask(readFirstSupervisorMessage);
    //StartTask(sendRobotPosition);
    // restante do codigo do robo
    //grab();
    //grab();
    sair_base();
    //OnRevSync(OUT_BC, 50, 0);
    //Wait(6000);
}
